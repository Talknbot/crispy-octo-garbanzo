{
  "workflow": {
    "id": "3CHTe1GoIZtw7fYT",
    "meta": {
      "instanceId": "f31c8cf0f30c343fde4e229f596b53099ee0496367bfd39c53458e5afe95e91e"
    },
    "name": "API Integration Testing & Monitoring MCP Server",
    "tags": [],
    "nodes": [
      {
        "id": "5d8f6345-482c-4cdf-9574-7cf13802202e",
        "name": "MCP Server - API Monitor Entry",
        "type": "@n8n/n8n-nodes-langchain.mcpTrigger",
        "position": [
          -944,
          -576
        ],
        "webhookId": "55fbc57f-25f2-4c2c-b807-a7318498fa31",
        "parameters": {
          "path": "api-monitoring-server",
          "authentication": "bearerAuth"
        },
        "typeVersion": 2
      },
      {
        "id": "7f2db1a9-7586-4503-8c84-7d5cc0e99378",
        "name": "Analyze API Health",
        "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
        "position": [
          -1152,
          -256
        ],
        "parameters": {
          "source": "parameter",
          "description": "Analyzes API endpoint health including response times, status codes, SSL certificates, and detects anomalies using historical data patterns.",
          "workflowJson": "{\n  \"meta\": {\n    \"instanceId\": \"api-health-monitor\"\n  },\n  \"nodes\": [\n    {\n      \"id\": \"execute-workflow-trigger\",\n      \"name\": \"Execute Workflow Trigger\",\n      \"type\": \"nodes-base.executeWorkflowTrigger\",\n      \"typeVersion\": 1,\n      \"position\": [0, 0],\n      \"parameters\": {}\n    },\n    {\n      \"id\": \"test-api-endpoint\",\n      \"name\": \"Test API Endpoint\",\n      \"type\": \"nodes-base.httpRequest\",\n      \"typeVersion\": 4.2,\n      \"position\": [200, 0],\n      \"parameters\": {\n        \"url\": \"={{ $json.endpoint_url }}\",\n        \"options\": {\n          \"response\": {\n            \"response\": {\n              \"responseFormat\": \"json\"\n            }\n          },\n          \"timeout\": 10000\n        }\n      }\n    },\n    {\n      \"id\": \"analyze-response\",\n      \"name\": \"Analyze Response\",\n      \"type\": \"nodes-base.code\",\n      \"typeVersion\": 2,\n      \"position\": [400, 0],\n      \"parameters\": {\n        \"language\": \"javascript\",\n        \"jsCode\": \"const response = $input.first().json;\\nconst responseTime = response.response?.timings?.response || 0;\\nconst statusCode = response.response?.statusCode || 0;\\n\\nconst isHealthy = statusCode >= 200 && statusCode < 300;\\nconst healthStatus = !isHealthy ? &apos;CRITICAL&apos; : responseTime > 2000 ? &apos;WARNING&apos; : &apos;HEALTHY&apos;;\\n\\nreturn [{\\n  tool_name: &apos;analyze_api_health&apos;,\\n  timestamp: new Date().toISOString(),\\n  endpoint: $json.endpoint_url,\\n  health_status: healthStatus,\\n  metrics: {\\n    status_code: statusCode,\\n    response_time_ms: responseTime,\\n    is_healthy: isHealthy\\n  },\\n  recommendations: !isHealthy ? [&apos;Check API endpoint immediately&apos;] : [&apos;API operating normally&apos;]\\n}];\"\n      }\n    }\n  ],\n  \"connections\": {\n    \"Execute Workflow Trigger\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Test API Endpoint\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Test API Endpoint\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Analyze Response\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    }\n  }\n}\n\n\n\n\n\n\n\n\n"
        },
        "typeVersion": 2.2
      },
      {
        "id": "4b83da51-ab52-4817-9aba-03ff307e74dd",
        "name": "Validate Webhook Reliability",
        "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
        "position": [
          -992,
          -256
        ],
        "parameters": {
          "source": "parameter",
          "description": "Tests webhook delivery reliability by sending test payloads and measuring success rates, response times, and retry behavior for webhook endpoints.\n\n",
          "workflowJson": "{\n  \"meta\": {\n    \"instanceId\": \"webhook-reliability-monitor\"\n  },\n  \"nodes\": [\n    {\n      \"id\": \"execute-workflow-trigger\",\n      \"name\": \"Execute Workflow Trigger\",\n      \"type\": \"nodes-base.executeWorkflowTrigger\",\n      \"typeVersion\": 1,\n      \"position\": [0, 0],\n      \"parameters\": {}\n    },\n    {\n      \"id\": \"test-webhook-delivery\",\n      \"name\": \"Test Webhook Delivery\",\n      \"type\": \"nodes-base.httpRequest\",\n      \"typeVersion\": 4.2,\n      \"position\": [200, 0],\n      \"parameters\": {\n        \"url\": \"={{ $json.webhook_url }}\",\n        \"method\": \"POST\",\n        \"body\": {\n          \"mode\": \"json\",\n          \"jsonData\": \"={{ JSON.stringify({\\n  test_payload: true,\\n  timestamp: new Date().toISOString(),\\n  test_id: &apos;webhook_reliability_&apos; + Date.now()\\n}) }}\"\n        },\n        \"options\": {\n          \"response\": {\n            \"response\": {\n              \"responseFormat\": \"json\"\n            }\n          },\n          \"timeout\": 15000,\n          \"retry\": {\n            \"enabled\": true,\n            \"maxRetries\": 3,\n            \"retryDelay\": 1000\n          }\n        }\n      }\n    },\n    {\n      \"id\": \"analyze-webhook-response\",\n      \"name\": \"Analyze Webhook Response\",\n      \"type\": \"nodes-base.code\",\n      \"typeVersion\": 2,\n      \"position\": [400, 0],\n      \"parameters\": {\n        \"language\": \"javascript\",\n        \"jsCode\": \"const response = $input.first().json;\\nconst responseTime = response.response?.timings?.response || 0;\\nconst statusCode = response.response?.statusCode || 0;\\nconst retryCount = response.response?.retryCount || 0;\\n\\n// Determine webhook reliability\\nconst isSuccessful = statusCode >= 200 && statusCode < 300;\\nconst isReliable = isSuccessful && responseTime < 5000; // 5 second threshold\\nconst reliabilityStatus = !isSuccessful ? &apos;FAILED&apos; : !isReliable ? &apos;SLOW&apos; : &apos;RELIABLE&apos;;\\n\\n// Calculate success metrics\\nconst deliverySuccess = isSuccessful;\\nconst averageResponseTime = responseTime;\\nconst totalRetries = retryCount;\\n\\n// Generate reliability report\\nconst recommendations = [];\\nif (!isSuccessful) {\\n  recommendations.push(&apos;Check webhook endpoint configuration&apos;);\\n  recommendations.push(&apos;Verify webhook URL is accessible&apos;);\\n  recommendations.push(&apos;Check authentication requirements&apos;);\\n}\\nif (responseTime > 5000) {\\n  recommendations.push(&apos;Webhook response time is slow&apos;);\\n  recommendations.push(&apos;Consider optimizing webhook handler&apos;);\\n}\\nif (retryCount > 0) {\\n  recommendations.push(`Webhook required ${retryCount} retries`);\\n}\\nif (reliabilityStatus === &apos;RELIABLE&apos;) {\\n  recommendations.push(&apos;Webhook operating reliably&apos;);\\n}\\n\\nreturn [{\\n  tool_name: &apos;validate_webhook_reliability&apos;,\\n  timestamp: new Date().toISOString(),\\n  webhook_url: $json.webhook_url,\\n  reliability_status: reliabilityStatus,\\n  delivery_metrics: {\\n    success: deliverySuccess,\\n    status_code: statusCode,\\n    response_time_ms: responseTime,\\n    retry_count: totalRetries,\\n    delivery_rate: deliverySuccess ? 100 : 0\\n  },\\n  performance_analysis: {\\n    is_fast: responseTime < 2000,\\n    is_acceptable: responseTime < 5000,\\n    requires_optimization: responseTime > 5000\\n  },\\n  recommendations: recommendations,\\n  test_details: {\\n    test_payload_sent: true,\\n    test_timestamp: new Date().toISOString(),\\n    endpoint_reachable: statusCode !== 0\\n  }\\n}];\"\n      }\n    }\n  ],\n  \"connections\": {\n    \"Execute Workflow Trigger\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Test Webhook Delivery\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Test Webhook Delivery\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Analyze Webhook Response\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    }\n  }\n}\n\n\n\n\n\n\n\n\n"
        },
        "typeVersion": 2.2
      },
      {
        "id": "28ed2bf1-0101-4376-8f6c-e8b9b68d10ee",
        "name": "Monitor API Limits",
        "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
        "position": [
          -832,
          -256
        ],
        "parameters": {
          "source": "parameter",
          "description": "Monitors API rate limits by checking rate limit headers, calculating usage percentages and burn rates, predicting time to exhaustion, and alerting on approaching limits.",
          "workflowJson": "{\n  \"meta\": {\n    \"instanceId\": \"api-limits-monitor\"\n  },\n  \"nodes\": [\n    {\n      \"id\": \"execute-workflow-trigger\",\n      \"name\": \"Execute Workflow Trigger\",\n      \"type\": \"nodes-base.executeWorkflowTrigger\",\n      \"typeVersion\": 1,\n      \"position\": [0, 0],\n      \"parameters\": {}\n    },\n    {\n      \"id\": \"check-rate-limits\",\n      \"name\": \"Check Rate Limits\",\n      \"type\": \"nodes-base.httpRequest\",\n      \"typeVersion\": 4.2,\n      \"position\": [200, 0],\n      \"parameters\": {\n        \"url\": \"={{ $json.endpoint_url }}\",\n        \"method\": \"GET\",\n        \"sendHeaders\": true,\n        \"headerParameters\": {\n          \"parameters\": [\n            {\n              \"name\": \"Authorization\",\n              \"value\": \"={{ $json.auth_type === &apos;bearer&apos; ? &apos;Bearer &apos; + $json.auth_token : $json.auth_type === &apos;apikey&apos; ? $json.auth_token : &apos;Basic &apos; + Buffer.from($json.auth_token).toString(&apos;base64&apos;) }}\"\n            }\n          ]\n        },\n        \"options\": {\n          \"response\": {\n            \"response\": {\n              \"responseFormat\": \"json\",\n              \"fullResponse\": true\n            }\n          },\n          \"timeout\": 10000\n        }\n      }\n    },\n    {\n      \"id\": \"analyze-rate-limits\",\n      \"name\": \"Analyze Rate Limits\",\n      \"type\": \"nodes-base.code\",\n      \"typeVersion\": 2,\n      \"position\": [400, 0],\n      \"parameters\": {\n        \"language\": \"javascript\",\n        \"jsCode\": \"const response = $input.first().json;\\nconst headers = response.headers || {};\\nconst statusCode = response.statusCode || 0;\\n\\n// Extract rate limit headers (common variations)\\nconst rateLimitUsed = parseInt(headers[&apos;x-ratelimit-used&apos;] || headers[&apos;x-rate-limit-used&apos;] || headers[&apos;ratelimit-used&apos;] || 0);\\nconst rateLimitLimit = parseInt(headers[&apos;x-ratelimit-limit&apos;] || headers[&apos;x-rate-limit-limit&apos;] || headers[&apos;ratelimit-limit&apos;] || 0);\\nconst rateLimitReset = parseInt(headers[&apos;x-ratelimit-reset&apos;] || headers[&apos;x-rate-limit-reset&apos;] || headers[&apos;ratelimit-reset&apos;] || 0);\\nconst rateLimitRemaining = parseInt(headers[&apos;x-ratelimit-remaining&apos;] || headers[&apos;x-rate-limit-remaining&apos;] || headers[&apos;ratelimit-remaining&apos;] || (rateLimitLimit - rateLimitUsed));\\n\\n// Calculate metrics\\nconst usagePercentage = rateLimitLimit > 0 ? Math.round((rateLimitUsed / rateLimitLimit) * 100) : 0;\\nconst remainingPercentage = rateLimitLimit > 0 ? Math.round((rateLimitRemaining / rateLimitLimit) * 100) : 100;\\n\\n// Calculate time to reset\\nconst currentTime = Math.floor(Date.now() / 1000);\\nconst timeToReset = rateLimitReset > 0 ? rateLimitReset - currentTime : 0;\\nconst resetInMinutes = Math.max(0, Math.floor(timeToReset / 60));\\n\\n// Calculate burn rate (requests per minute)\\nconst timeWindow = 3600; // Assume 1 hour window\\nconst burnRate = rateLimitLimit > 0 && timeWindow > 0 ? Math.round((rateLimitUsed / timeWindow) * 60) : 0;\\n\\n// Predict time to exhaustion\\nconst requestsRemaining = rateLimitRemaining;\\nconst minutesToExhaustion = burnRate > 0 && requestsRemaining > 0 ? Math.floor(requestsRemaining / burnRate) : -1;\\n\\n// Determine alert status\\nlet alertStatus = &apos;NORMAL&apos;;\\nif (usagePercentage >= 90) {\\n  alertStatus = &apos;CRITICAL&apos;;\\n} else if (usagePercentage >= 75) {\\n  alertStatus = &apos;WARNING&apos;;\\n} else if (usagePercentage >= 50) {\\n  alertStatus = &apos;WATCH&apos;;\\n}\\n\\n// Generate recommendations\\nconst recommendations = [];\\nif (usagePercentage >= 90) {\\n  recommendations.push(&apos;URGENT: Rate limit nearly exhausted - reduce API calls immediately&apos;);\\n  recommendations.push(&apos;Implement request queuing or throttling&apos;);\\n} else if (usagePercentage >= 75) {\\n  recommendations.push(&apos;Rate limit usage is high - monitor closely&apos;);\\n} else if (usagePercentage >= 50) {\\n  recommendations.push(&apos;Rate limit usage is moderate - continue monitoring&apos;);\\n} else {\\n  recommendations.push(&apos;Rate limit usage is low - operating normally&apos;);\\n}\\n\\nif (minutesToExhaustion > 0 && minutesToExhaustion < 60) {\\n  recommendations.push(`Rate limit will be exhausted in approximately ${minutesToExhaustion} minutes`);\\n}\\n\\nif (timeToReset > 0) {\\n  recommendations.push(`Rate limit resets in ${resetInMinutes} minutes`);\\n}\\n\\nreturn [{\\n  tool_name: &apos;monitor_api_limits&apos;,\\n  timestamp: new Date().toISOString(),\\n  endpoint: $json.endpoint_url,\\n  limit_status: alertStatus,\\n  rate_limit_metrics: {\\n    used: rateLimitUsed,\\n    limit: rateLimitLimit,\\n    remaining: rateLimitRemaining,\\n    usage_percentage: usagePercentage,\\n    remaining_percentage: remainingPercentage\\n  },\\n  timing_analysis: {\\n    reset_timestamp: rateLimitReset,\\n    time_to_reset_minutes: resetInMinutes,\\n    burn_rate_per_minute: burnRate,\\n    estimated_exhaustion_minutes: minutesToExhaustion\\n  },\\n  recommendations: recommendations,\\n  requires_immediate_action: usagePercentage >= 90\\n}];\"\n      }\n    }\n  ],\n  \"connections\": {\n    \"Execute Workflow Trigger\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Check Rate Limits\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Check Rate Limits\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Analyze Rate Limits\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    }\n  }\n}\n\n\n\n\n\n\n\n\n"
        },
        "typeVersion": 2.2
      },
      {
        "id": "97d9cc34-44ab-48a9-88a6-4ea888cad3dd",
        "name": "Verify Authentication",
        "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
        "position": [
          -672,
          -256
        ],
        "parameters": {
          "source": "parameter",
          "description": "Tests different authentication methods (Bearer, API key, Basic auth), validates token expiration, checks authentication response codes, and monitors auth failure patterns.",
          "workflowJson": "{\n  \"meta\": {\n    \"instanceId\": \"auth-verification-monitor\"\n  },\n  \"nodes\": [\n    {\n      \"id\": \"execute-workflow-trigger\",\n      \"name\": \"Execute Workflow Trigger\",\n      \"type\": \"nodes-base.executeWorkflowTrigger\",\n      \"typeVersion\": 1,\n      \"position\": [0, 0],\n      \"parameters\": {}\n    },\n    {\n      \"id\": \"test-authentication\",\n      \"name\": \"Test Authentication\",\n      \"type\": \"nodes-base.httpRequest\",\n      \"typeVersion\": 4.2,\n      \"position\": [200, 0],\n      \"parameters\": {\n        \"url\": \"={{ $json.endpoint_url }}\",\n        \"method\": \"GET\",\n        \"sendHeaders\": true,\n        \"headerParameters\": {\n          \"parameters\": [\n            {\n              \"name\": \"Authorization\",\n              \"value\": \"={{ $json.auth_type === &apos;bearer&apos; ? &apos;Bearer &apos; + $json.auth_token : $json.auth_type === &apos;apikey&apos; ? $json.auth_token : &apos;Basic &apos; + Buffer.from($json.auth_token).toString(&apos;base64&apos;) }}\"\n            }\n          ]\n        },\n        \"options\": {\n          \"response\": {\n            \"response\": {\n              \"responseFormat\": \"json\",\n              \"fullResponse\": true\n            }\n          },\n          \"timeout\": 10000,\n          \"retry\": {\n            \"enabled\": false\n          }\n        }\n      }\n    },\n    {\n      \"id\": \"analyze-auth-response\",\n      \"name\": \"Analyze Auth Response\",\n      \"type\": \"nodes-base.code\",\n      \"typeVersion\": 2,\n      \"position\": [400, 0],\n      \"parameters\": {\n        \"language\": \"javascript\",\n        \"jsCode\": \"const response = $input.first().json;\\nconst statusCode = response.statusCode || 0;\\nconst headers = response.headers || {};\\nconst responseBody = response.body || {};\\nconst responseTime = response.response?.timings?.response || 0;\\n\\n// Determine authentication status\\nlet authStatus = &apos;UNKNOWN&apos;;\\nlet authValid = false;\\nlet tokenExpired = false;\\nlet insufficientPermissions = false;\\n\\nif (statusCode === 200 || statusCode === 201) {\\n  authStatus = &apos;VALID&apos;;\\n  authValid = true;\\n} else if (statusCode === 401) {\\n  authStatus = &apos;INVALID&apos;;\\n  // Check if it&apos;s token expiration\\n  const errorMessage = JSON.stringify(responseBody).toLowerCase();\\n  if (errorMessage.includes(&apos;expired&apos;) || errorMessage.includes(&apos;token&apos;) && errorMessage.includes(&apos;invalid&apos;)) {\\n    tokenExpired = true;\\n    authStatus = &apos;EXPIRED&apos;;\\n  }\\n} else if (statusCode === 403) {\\n  authStatus = &apos;INSUFFICIENT_PERMISSIONS&apos;;\\n  insufficientPermissions = true;\\n} else if (statusCode === 429) {\\n  authStatus = &apos;RATE_LIMITED&apos;;\\n} else if (statusCode >= 500) {\\n  authStatus = &apos;SERVER_ERROR&apos;;\\n} else {\\n  authStatus = &apos;FAILED&apos;;\\n}\\n\\n// Analyze auth method effectiveness\\nconst authMethod = $json.auth_type || &apos;unknown&apos;;\\nlet methodAnalysis = {\\n  type: authMethod,\\n  working: authValid,\\n  response_time_ms: responseTime\\n};\\n\\n// Check for auth-specific headers\\nconst authHeaders = {\\n  &apos;www-authenticate&apos;: headers[&apos;www-authenticate&apos;] || null,\\n  &apos;authorization&apos;: headers[&apos;authorization&apos;] ? &apos;present&apos; : &apos;missing&apos;,\\n  &apos;x-api-key&apos;: headers[&apos;x-api-key&apos;] ? &apos;present&apos; : &apos;missing&apos;\\n};\\n\\n// Generate failure patterns analysis\\nconst failurePatterns = [];\\nif (statusCode === 401) {\\n  failurePatterns.push(&apos;Authentication credentials rejected&apos;);\\n  if (tokenExpired) {\\n    failurePatterns.push(&apos;Token appears to be expired&apos;);\\n  }\\n}\\nif (statusCode === 403) {\\n  failurePatterns.push(&apos;Insufficient permissions for this endpoint&apos;);\\n}\\nif (responseTime > 5000) {\\n  failurePatterns.push(&apos;Slow authentication response time&apos;);\\n}\\n\\n// Generate recommendations\\nconst recommendations = [];\\nif (authValid) {\\n  recommendations.push(&apos;Authentication is working correctly&apos;);\\n  if (responseTime > 2000) {\\n    recommendations.push(&apos;Consider monitoring auth response times&apos;);\\n  }\\n} else {\\n  if (tokenExpired) {\\n    recommendations.push(&apos;URGENT: Refresh or renew authentication token&apos;);\\n    recommendations.push(&apos;Implement automatic token refresh mechanism&apos;);\\n  } else if (insufficientPermissions) {\\n    recommendations.push(&apos;Check API permissions and scopes&apos;);\\n    recommendations.push(&apos;Verify account has required access levels&apos;);\\n  } else if (statusCode === 401) {\\n    recommendations.push(&apos;Verify authentication credentials are correct&apos;);\\n    recommendations.push(&apos;Check auth method matches API requirements&apos;);\\n  } else {\\n    recommendations.push(&apos;Check API endpoint and authentication method&apos;);\\n    recommendations.push(&apos;Verify network connectivity to auth server&apos;);\\n  }\\n}\\n\\nreturn [{\\n  tool_name: &apos;verify_authentication&apos;,\\n  timestamp: new Date().toISOString(),\\n  endpoint: $json.endpoint_url,\\n  auth_status: authStatus,\\n  authentication_results: {\\n    is_valid: authValid,\\n    status_code: statusCode,\\n    response_time_ms: responseTime,\\n    auth_method: authMethod,\\n    token_expired: tokenExpired,\\n    insufficient_permissions: insufficientPermissions\\n  },\\n  method_analysis: methodAnalysis,\\n  failure_patterns: failurePatterns,\\n  auth_headers_detected: authHeaders,\\n  recommendations: recommendations,\\n  requires_immediate_action: tokenExpired || (statusCode === 401 && !tokenExpired)\\n}];\"\n      }\n    }\n  ],\n  \"connections\": {\n    \"Execute Workflow Trigger\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Test Authentication\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Test Authentication\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Analyze Auth Response\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    }\n  }\n}\n\n\n\n\n\n\n\n\n"
        },
        "typeVersion": 2.2
      },
      {
        "id": "9436b97f-9cfa-448c-a5cb-920bc5b26cdd",
        "name": "Generate Client Report",
        "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
        "position": [
          -528,
          -256
        ],
        "parameters": {
          "source": "parameter",
          "description": "Aggregates monitoring data from other tools to create comprehensive client reports with executive summaries, performance metrics, and actionable recommendations.",
          "workflowJson": "{\n  \"meta\": {\n    \"instanceId\": \"client-report-generator\"\n  },\n  \"nodes\": [\n    {\n      \"id\": \"execute-workflow-trigger\",\n      \"name\": \"Execute Workflow Trigger\",\n      \"type\": \"nodes-base.executeWorkflowTrigger\",\n      \"typeVersion\": 1,\n      \"position\": [0, 0],\n      \"parameters\": {}\n    },\n    {\n      \"id\": \"aggregate-monitoring-data\",\n      \"name\": \"Aggregate Monitoring Data\",\n      \"type\": \"nodes-base.code\",\n      \"typeVersion\": 2,\n      \"position\": [200, 0],\n      \"parameters\": {\n        \"language\": \"javascript\",\n        \"jsCode\": \"// Get input data - could be from previous tool executions or provided data\\nconst inputData = $input.first().json;\\n\\n// Extract individual tool results if they exist\\nconst apiHealthData = inputData.api_health_data || {};\\nconst webhookData = inputData.webhook_data || {};\\nconst limitsData = inputData.limits_data || {};\\nconst authData = inputData.auth_data || {};\\n\\n// Or use the current input as a single tool result\\nconst toolData = inputData.tool_name ? inputData : {};\\n\\n// Initialize aggregated metrics\\nlet overallHealth = &apos;UNKNOWN&apos;;\\nlet criticalIssues = [];\\nlet warnings = [];\\nlet recommendations = [];\\nlet healthScore = 0;\\n\\n// Analyze API Health\\nif (apiHealthData.health_status || toolData.tool_name === &apos;analyze_api_health&apos;) {\\n  const healthStatus = apiHealthData.health_status || toolData.health_status;\\n  if (healthStatus === &apos;CRITICAL&apos;) {\\n    criticalIssues.push(&apos;API endpoint health is critical&apos;);\\n    healthScore += 0;\\n  } else if (healthStatus === &apos;WARNING&apos;) {\\n    warnings.push(&apos;API endpoint has performance issues&apos;);\\n    healthScore += 50;\\n  } else if (healthStatus === &apos;HEALTHY&apos;) {\\n    healthScore += 100;\\n  }\\n}\\n\\n// Analyze Webhook Reliability\\nif (webhookData.reliability_status || toolData.tool_name === &apos;validate_webhook_reliability&apos;) {\\n  const webhookStatus = webhookData.reliability_status || toolData.reliability_status;\\n  if (webhookStatus === &apos;FAILED&apos;) {\\n    criticalIssues.push(&apos;Webhook delivery is failing&apos;);\\n    healthScore += 0;\\n  } else if (webhookStatus === &apos;SLOW&apos;) {\\n    warnings.push(&apos;Webhook response times are slow&apos;);\\n    healthScore += 50;\\n  } else if (webhookStatus === &apos;RELIABLE&apos;) {\\n    healthScore += 100;\\n  }\\n}\\n\\n// Analyze Rate Limits\\nif (limitsData.limit_status || toolData.tool_name === &apos;monitor_api_limits&apos;) {\\n  const limitStatus = limitsData.limit_status || toolData.limit_status;\\n  if (limitStatus === &apos;CRITICAL&apos;) {\\n    criticalIssues.push(&apos;API rate limits nearly exhausted&apos;);\\n    healthScore += 0;\\n  } else if (limitStatus === &apos;WARNING&apos;) {\\n    warnings.push(&apos;API rate limit usage is high&apos;);\\n    healthScore += 50;\\n  } else if (limitStatus === &apos;WATCH&apos;) {\\n    warnings.push(&apos;API rate limit usage should be monitored&apos;);\\n    healthScore += 75;\\n  } else if (limitStatus === &apos;NORMAL&apos;) {\\n    healthScore += 100;\\n  }\\n}\\n\\n// Analyze Authentication\\nif (authData.auth_status || toolData.tool_name === &apos;verify_authentication&apos;) {\\n  const authStatus = authData.auth_status || toolData.auth_status;\\n  if (authStatus === &apos;INVALID&apos; || authStatus === &apos;EXPIRED&apos;) {\\n    criticalIssues.push(&apos;Authentication is failing&apos;);\\n    healthScore += 0;\\n  } else if (authStatus === &apos;INSUFFICIENT_PERMISSIONS&apos;) {\\n    warnings.push(&apos;Authentication has insufficient permissions&apos;);\\n    healthScore += 25;\\n  } else if (authStatus === &apos;VALID&apos;) {\\n    healthScore += 100;\\n  }\\n}\\n\\n// Calculate overall health based on number of tools checked\\nconst toolsChecked = Math.max(1, Object.keys({apiHealthData, webhookData, limitsData, authData}).filter(key => \\n  eval(key) && Object.keys(eval(key)).length > 0\\n).length);\\n\\nconst averageScore = healthScore / toolsChecked;\\n\\nif (criticalIssues.length > 0) {\\n  overallHealth = &apos;CRITICAL&apos;;\\n} else if (warnings.length > 0) {\\n  overallHealth = &apos;WARNING&apos;;\\n} else if (averageScore >= 80) {\\n  overallHealth = &apos;HEALTHY&apos;;\\n} else {\\n  overallHealth = &apos;DEGRADED&apos;;\\n}\\n\\nreturn [{\\n  aggregated_data: {\\n    overall_health: overallHealth,\\n    health_score: Math.round(averageScore),\\n    critical_issues: criticalIssues,\\n    warnings: warnings,\\n    tools_monitored: toolsChecked,\\n    api_health: apiHealthData,\\n    webhook_reliability: webhookData,\\n    rate_limits: limitsData,\\n    authentication: authData,\\n    single_tool_data: toolData\\n  }\\n}];\"\n      }\n    },\n    {\n      \"id\": \"generate-client-report\",\n      \"name\": \"Generate Client Report\",\n      \"type\": \"nodes-base.code\",\n      \"typeVersion\": 2,\n      \"position\": [400, 0],\n      \"parameters\": {\n        \"language\": \"javascript\",\n        \"jsCode\": \"const data = $input.first().json.aggregated_data;\\nconst timestamp = new Date().toISOString();\\nconst reportDate = new Date().toLocaleDateString();\\n\\n// Generate Executive Summary\\nlet executiveSummary = &apos;&apos;;\\nif (data.overall_health === &apos;CRITICAL&apos;) {\\n  executiveSummary = `URGENT: Your API integrations require immediate attention. ${data.critical_issues.length} critical issues detected that may impact service availability.`;\\n} else if (data.overall_health === &apos;WARNING&apos;) {\\n  executiveSummary = `Your API integrations are operational but showing signs of degradation. ${data.warnings.length} warnings require monitoring.`;\\n} else if (data.overall_health === &apos;HEALTHY&apos;) {\\n  executiveSummary = &apos;Your API integrations are performing well with no critical issues detected. Continue current monitoring practices.&apos;;\\n} else {\\n  executiveSummary = &apos;API integration health assessment completed. Review detailed findings below.&apos;;\\n}\\n\\n// Generate Performance Metrics Summary\\nconst performanceMetrics = {\\n  overall_health_score: `${data.health_score}/100`,\\n  system_status: data.overall_health,\\n  critical_issues_count: data.critical_issues.length,\\n  warnings_count: data.warnings.length,\\n  monitoring_coverage: `${data.tools_monitored} tools active`\\n};\\n\\n// Generate Detailed Findings\\nconst detailedFindings = [];\\n\\nif (data.api_health && Object.keys(data.api_health).length > 0) {\\n  detailedFindings.push({\\n    category: &apos;API Health&apos;,\\n    status: data.api_health.health_status || &apos;Unknown&apos;,\\n    metrics: data.api_health.metrics || {},\\n    key_finding: data.api_health.health_status === &apos;HEALTHY&apos; ? &apos;API responding normally&apos; : &apos;API performance issues detected&apos;\\n  });\\n}\\n\\nif (data.webhook_reliability && Object.keys(data.webhook_reliability).length > 0) {\\n  detailedFindings.push({\\n    category: &apos;Webhook Reliability&apos;,\\n    status: data.webhook_reliability.reliability_status || &apos;Unknown&apos;,\\n    metrics: data.webhook_reliability.delivery_metrics || {},\\n    key_finding: data.webhook_reliability.reliability_status === &apos;RELIABLE&apos; ? &apos;Webhooks delivering successfully&apos; : &apos;Webhook delivery issues detected&apos;\\n  });\\n}\\n\\nif (data.rate_limits && Object.keys(data.rate_limits).length > 0) {\\n  detailedFindings.push({\\n    category: &apos;Rate Limits&apos;,\\n    status: data.rate_limits.limit_status || &apos;Unknown&apos;,\\n    metrics: data.rate_limits.rate_limit_metrics || {},\\n    key_finding: data.rate_limits.limit_status === &apos;NORMAL&apos; ? &apos;Rate limit usage is normal&apos; : &apos;Rate limit concerns detected&apos;\\n  });\\n}\\n\\nif (data.authentication && Object.keys(data.authentication).length > 0) {\\n  detailedFindings.push({\\n    category: &apos;Authentication&apos;,\\n    status: data.authentication.auth_status || &apos;Unknown&apos;,\\n    metrics: data.authentication.authentication_results || {},\\n    key_finding: data.authentication.auth_status === &apos;VALID&apos; ? &apos;Authentication working correctly&apos; : &apos;Authentication issues detected&apos;\\n  });\\n}\\n\\n// Generate Prioritized Recommendations\\nconst prioritizedRecommendations = [];\\n\\n// Critical recommendations first\\nif (data.critical_issues.length > 0) {\\n  prioritizedRecommendations.push({\\n    priority: &apos;URGENT&apos;,\\n    category: &apos;Critical Issues&apos;,\\n    actions: data.critical_issues.map(issue => `Address: ${issue}`)\\n  });\\n}\\n\\n// Warning recommendations\\nif (data.warnings.length > 0) {\\n  prioritizedRecommendations.push({\\n    priority: &apos;HIGH&apos;,\\n    category: &apos;Performance Optimization&apos;,\\n    actions: data.warnings.map(warning => `Monitor: ${warning}`)\\n  });\\n}\\n\\n// General recommendations\\nif (data.overall_health === &apos;HEALTHY&apos;) {\\n  prioritizedRecommendations.push({\\n    priority: &apos;MEDIUM&apos;,\\n    category: &apos;Maintenance&apos;,\\n    actions: [\\n      &apos;Continue regular monitoring schedule&apos;,\\n      &apos;Review performance trends monthly&apos;,\\n      &apos;Maintain current monitoring configuration&apos;\\n    ]\\n  });\\n}\\n\\n// Next Steps\\nconst nextSteps = [];\\nif (data.critical_issues.length > 0) {\\n  nextSteps.push(&apos;1. Address critical issues immediately (within 24 hours)&apos;);\\n  nextSteps.push(&apos;2. Implement monitoring alerts for critical thresholds&apos;);\\n  nextSteps.push(&apos;3. Schedule follow-up assessment in 48 hours&apos;);\\n} else if (data.warnings.length > 0) {\\n  nextSteps.push(&apos;1. Review warning conditions (within 7 days)&apos;);\\n  nextSteps.push(&apos;2. Optimize performance where possible&apos;);\\n  nextSteps.push(&apos;3. Schedule follow-up assessment in 2 weeks&apos;);\\n} else {\\n  nextSteps.push(&apos;1. Continue current monitoring schedule&apos;);\\n  nextSteps.push(&apos;2. Review monthly performance trends&apos;);\\n  nextSteps.push(&apos;3. Next comprehensive assessment in 30 days&apos;);\\n}\\n\\nreturn [{\\n  tool_name: &apos;generate_client_report&apos;,\\n  timestamp: timestamp,\\n  report_date: reportDate,\\n  report_summary: {\\n    overall_status: data.overall_health,\\n    health_score: data.health_score,\\n    requires_attention: data.critical_issues.length > 0 || data.warnings.length > 0\\n  },\\n  executive_summary: executiveSummary,\\n  performance_metrics: performanceMetrics,\\n  detailed_findings: detailedFindings,\\n  prioritized_recommendations: prioritizedRecommendations,\\n  next_steps: nextSteps,\\n  report_metadata: {\\n    generated_by: &apos;API Integration Monitoring System&apos;,\\n    report_type: &apos;Comprehensive Integration Health Assessment&apos;,\\n    monitoring_period: &apos;24 hours&apos;,\\n    tools_analyzed: data.tools_monitored\\n  }\\n}];\"\n      }\n    }\n  ],\n  \"connections\": {\n    \"Execute Workflow Trigger\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Aggregate Monitoring Data\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Aggregate Monitoring Data\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Generate Client Report\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    }\n  }\n}\n\n\n\n\n\n\n\n\n"
        },
        "typeVersion": 2.2
      },
      {
        "id": "8dad92eb-4466-47ec-ba3a-e9a18b64aafb",
        "name": "Sticky Note1",
        "type": "n8n-nodes-base.stickyNote",
        "position": [
          -1392,
          -336
        ],
        "parameters": {
          "color": 5,
          "width": 1056,
          "height": 640,
          "content": "## \ud83d\udd27 Available MCP Tools\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n**Analyze API Health**\n\ud83d\udccb Tests endpoint response times, status codes, and overall health\n\ud83c\udfaf Use: Check if APIs are responding normally\n\n**Validate Webhook Reliability** \n\ud83d\udccb Tests webhook delivery with retry analysis\n\ud83c\udfaf Use: Verify webhook endpoints are receiving data properly\n\n**Monitor API Limits**\n\ud83d\udccb Checks rate limit headers and usage percentages  \n\ud83c\udfaf Use: Prevent rate limit exhaustion and plan usage\n\n**Verify Authentication**\n\ud83d\udccb Tests Bearer, API key, and Basic auth methods\n\ud83c\udfaf Use: Ensure API credentials are working correctly\n\n**Generate Client Report**\n\ud83d\udccb Creates comprehensive reports with executive summaries\n\ud83c\udfaf Use: Share API health status with stakeholders"
        },
        "typeVersion": 1
      },
      {
        "id": "24e39a69-90c9-4365-b994-093ffbd23fc7",
        "name": "Sticky Note2",
        "type": "n8n-nodes-base.stickyNote",
        "position": [
          -1008,
          -720
        ],
        "parameters": {
          "width": 422,
          "height": 304,
          "content": "\u2705 **Step 1: Configure MCP Server Access**\n- **MCP Server - API Monitor Entry** node: \n  - Path is pre-configured as \"api-monitoring-server\"\n  - Set up Bearer Auth credentials for secure access\n  - Generate a secure token for client connections"
        },
        "typeVersion": 1
      },
      {
        "id": "fbf995c5-8448-4e37-85ac-2fc0014aef17",
        "name": "Sticky Note3",
        "type": "n8n-nodes-base.stickyNote",
        "position": [
          -512,
          -1360
        ],
        "parameters": {
          "color": 4,
          "width": 432,
          "height": 944,
          "content": "\ud83d\udcca How to Use MCP Tools\n\n**Quick Test (Real Working URLs - Test These First!):**\nThese are verified testing endpoints that work immediately:\n\n\"Check the health of https://jsonplaceholder.typicode.com/posts/1\"\n\u2192 Free testing API, always returns 200 OK, no setup needed\n\n\"Test webhook delivery to https://httpbin.org/post\"\n\u2192 Instantly accepts POST data and shows what was received\n\n\"Monitor rate limits for https://api.github.com/rate_limit\"\n\u2192 Shows real rate limit headers, works without authentication\n\n\"Verify authentication with https://httpbin.org/basic-auth/test/test\"\n\u2192 Test credentials: username \"test\", password \"test\"\n\n**For Your Production APIs:**\nOnce you&apos;ve tested the tools, replace with your real endpoints:\n- Your API health check: https://your-api.com/health\n- Your webhook receiver: https://your-webhook.com/receive\n- Your authenticated endpoints with real credentials\n\n**Authentication Examples:**\n- Bearer: {\"auth_type\": \"bearer\", \"auth_token\": \"your_github_token\"}\n- API Key: {\"auth_type\": \"apikey\", \"auth_token\": \"your_api_key\"}  \n- Basic: {\"auth_type\": \"basic\", \"auth_token\": \"test:test\"}\n\n**What Each Test Does:**\n\u2705 JSONPlaceholder - Confirms API connectivity and response parsing\n\u2705 httpbin.org/post - Validates webhook delivery and payload handling  \n\u2705 GitHub rate_limit - Demonstrates real rate limit monitoring\n\u2705 httpbin basic-auth - Tests authentication validation flows\n\nStart with these test URLs to see the tools working, then switch to your own APIs!"
        },
        "typeVersion": 1
      },
      {
        "id": "71cfdd67-ac53-4042-a1a7-f86c1a21af09",
        "name": "Sticky Note4",
        "type": "n8n-nodes-base.stickyNote",
        "position": [
          -1600,
          -896
        ],
        "parameters": {
          "color": 6,
          "width": 512,
          "height": 480,
          "content": "\ud83d\udee0\ufe0f API Integration Testing & Monitoring MCP Server\n\nThis workflow creates a comprehensive MCP server that provides 5 specialized API monitoring tools accessible to external MCP clients like Claude Desktop or custom applications.\n\n\u2705 **Step 2: Deploy & Test Immediately**\n- Activate the workflow in your n8n instance\n- Copy the generated MCP server endpoint URL\n- **Quick Test**: Use the test URLs in the \"How to Use\" note to verify everything works\n- Then connect your real APIs and credentials\n\n\u2705 **Step 3: Connect MCP Client**\n- Configure Claude Desktop or your MCP client with the server endpoint\n- Add authentication token to client configuration\n- Test connection to verify all 5 tools are available\n\n\u2705 **Step 4: Start Monitoring APIs**\n- Begin with test URLs to see tools in action\n- Gradually replace with your production endpoints\n- Generate comprehensive reports for stakeholders"
        },
        "typeVersion": 1
      }
    ],
    "active": false,
    "pinData": {},
    "settings": {
      "executionOrder": "v1"
    },
    "versionId": "ba3b09df-b03e-4e24-83cf-2f27250036cf",
    "connections": {
      "Analyze API Health": {
        "ai_tool": [
          [
            {
              "node": "MCP Server - API Monitor Entry",
              "type": "ai_tool",
              "index": 0
            }
          ]
        ]
      },
      "Monitor API Limits": {
        "ai_tool": [
          [
            {
              "node": "MCP Server - API Monitor Entry",
              "type": "ai_tool",
              "index": 0
            }
          ]
        ]
      },
      "Verify Authentication": {
        "ai_tool": [
          [
            {
              "node": "MCP Server - API Monitor Entry",
              "type": "ai_tool",
              "index": 0
            }
          ]
        ]
      },
      "Generate Client Report": {
        "ai_tool": [
          [
            {
              "node": "MCP Server - API Monitor Entry",
              "type": "ai_tool",
              "index": 0
            }
          ]
        ]
      },
      "Validate Webhook Reliability": {
        "ai_tool": [
          [
            {
              "node": "MCP Server - API Monitor Entry",
              "type": "ai_tool",
              "index": 0
            }
          ]
        ]
      }
    }
  },
  "evaluation": {
    "overall_score": 25.0,
    "quality_tier": "bronze",
    "confidence": 0.7,
    "dimensions": {
      "architecture": 40.0,
      "error_handling": 10.0,
      "security": 20.0,
      "performance": 15.0,
      "maintainability": 50.0,
      "best_practices": 30.0,
      "scalability": 20.0,
      "innovation": 60.0
    },
    "auto_fix_suggestions": [
      {
        "type": "error_handling",
        "priority": "high",
        "description": "Add error handling after API-related nodes to catch failures.",
        "node_id": "Analyze API Health",
        "fix_details": {
          "action": "Insert Error Trigger node",
          "code_snippet": "Add a branch with 'On Error' to retry or log."
        }
      },
      {
        "type": "security",
        "priority": "critical",
        "description": "Secure authentication verification.",
        "node_id": "Verify Authentication",
        "fix_details": {
          "action": "Configure credential storage",
          "code_snippet": "Use n8n credential manager for API keys."
        }
      },
      {
        "type": "performance",
        "priority": "medium",
        "description": "Add caching to reduce redundant API calls.",
        "node_id": "Monitor API Limits",
        "fix_details": {
          "action": "Insert Cache node",
          "code_snippet": "Cache results for 5 minutes."
        }
      }
    ],
    "semantic_intent": {},
    "evaluation_cost": 0.9146536999999999,
    "evaluation_time": 8.476623058319092,
    "evaluator": "grok-code-fast-1"
  },
  "category": "AI",
  "category_metadata": {
    "primary_category": "AI",
    "confidence": 0.3956043956043956,
    "all_categories": [
      {
        "category": "AI",
        "confidence": 0.3956043956043956
      },
      {
        "category": "Customer Support",
        "confidence": 0.24725274725274723
      },
      {
        "category": "Content Creation",
        "confidence": 0.24725274725274723
      },
      {
        "category": "Data Processing",
        "confidence": 0.10989010989010989
      }
    ],
    "detection_sources": {
      "nodes": "",
      "architecture": "vertical",
      "pattern": "AI(0.80), Customer Support(0.50), Content Creation(0.50)",
      "nlp": "Data Processing(0.33)"
    },
    "architecture_type": "vertical",
    "category_quality_score": 53.333333333333336
  },
  "source_path": "C:\\Users\\DELL\\n8n-workflow-scraper\\data\\workflows\\staging_unique\\Customer_Support\\comprehensive-api-integration-suite-with-health-webhook-auth-rate-limit-monitoring-6607.json"
}